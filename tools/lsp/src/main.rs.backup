use std::error::Error;
use std::fs;
use std::path::Path;

use lsp_server::{Connection, Message, Notification, Request, RequestId, Response};
use lsp_types::notification::{
    DidChangeTextDocument, DidOpenTextDocument, Notification as _, PublishDiagnostics,
};
use lsp_types::*;
use serde_json::Value;

use bend_pvm::compiler::parser::{
    ast::{Definition, Expr, Location as AstLocation, LocationProvider, Program, Statement},
    parser::{ParseError, Parser},
};

fn main() -> Result<(), Box<dyn Error + Sync + Send>> {
    // Create the connection to the language server client
    let (connection, io_threads) = Connection::stdio();

    // Initialize the server capabilities
    let server_capabilities = serde_json::to_value(ServerCapabilities {
        text_document_sync: Some(TextDocumentSyncCapability::Kind(TextDocumentSyncKind::FULL)),
        completion_provider: Some(CompletionOptions {
            resolve_provider: Some(false),
            trigger_characters: Some(vec![".".to_string()]),
            ..CompletionOptions::default()
        }),
        hover_provider: Some(HoverProviderCapability::Simple(true)),
        definition_provider: Some(OneOf::Left(true)),
        references_provider: Some(OneOf::Left(true)),
        document_formatting_provider: Some(OneOf::Left(true)),
        ..ServerCapabilities::default()
    })
    .unwrap();

    // Initialize the server
    let params = connection.initialize(server_capabilities)?;
    let _init_params: InitializeParams = serde_json::from_value(params).unwrap();

    // Main loop
    for msg in &connection.receiver {
        match msg {
            Message::Request(req) => {
                if connection.handle_shutdown(&req)? {
                    break;
                }

                match handle_request(&connection, req) {
                    Ok(()) => {}
                    Err(e) => eprintln!("Error handling request: {}", e),
                }
            }
            Message::Response(_resp) => {}
            Message::Notification(not) => match handle_notification(&connection, not) {
                Ok(()) => {}
                Err(e) => eprintln!("Error handling notification: {}", e),
            },
        }
    }

    // Wait for the IO threads to finish
    io_threads.join()?;

    Ok(())
}

fn handle_request(
    connection: &Connection,
    req: Request,
) -> Result<(), Box<dyn Error + Sync + Send>> {
    match req.method.as_str() {
        "textDocument/completion" => {
            let params = serde_json::from_value::<CompletionParams>(req.params.clone())?;
            let completion_items = get_completion_items(&params);
            let result = Some(CompletionResponse::Array(completion_items));
            let resp = Response {
                id: req.id,
                result: Some(serde_json::to_value(result)?),
                error: None,
            };
            connection.sender.send(Message::Response(resp))?;
        }
        "textDocument/hover" => {
            let params = serde_json::from_value::<HoverParams>(req.params.clone())?;
            let hover = get_hover(&params);
            let resp = Response {
                id: req.id,
                result: Some(serde_json::to_value(hover)?),
                error: None,
            };
            connection.sender.send(Message::Response(resp))?;
        }
        "textDocument/definition" => {
            let params = serde_json::from_value::<GotoDefinitionParams>(req.params.clone())?;
            let location = get_definition(&params);
            let resp = Response {
                id: req.id,
                result: Some(serde_json::to_value(location)?),
                error: None,
            };
            connection.sender.send(Message::Response(resp))?;
        }
        "textDocument/references" => {
            let params = serde_json::from_value::<ReferenceParams>(req.params.clone())?;
            let references = find_references(&params);
            let resp = Response {
                id: req.id,
                result: Some(serde_json::to_value(references)?),
                error: None,
            };
            connection.sender.send(Message::Response(resp))?;
        }
        _ => {
            let resp = Response {
                id: req.id,
                result: Some(Value::Null),
                error: None,
            };
            connection.sender.send(Message::Response(resp))?;
        }
    }

    Ok(())
}

fn handle_notification(
    connection: &Connection,
    not: Notification,
) -> Result<(), Box<dyn Error + Sync + Send>> {
    match not.method.as_str() {
        DidOpenTextDocument::METHOD => {
            let params = serde_json::from_value::<DidOpenTextDocumentParams>(not.params)?;
            publish_diagnostics(
                connection,
                params.text_document.uri,
                &params.text_document.text,
            )?;
        }
        DidChangeTextDocument::METHOD => {
            let params = serde_json::from_value::<DidChangeTextDocumentParams>(not.params)?;
            // We use FULL sync, so there's only one change with the full text
            if let Some(change) = params.content_changes.first() {
                publish_diagnostics(connection, params.text_document.uri, &change.text)?;
            }
        }
        _ => {}
    }
    Ok(())
}

fn publish_diagnostics(
    connection: &Connection,
    uri: Url,
    text: &str,
) -> Result<(), Box<dyn Error + Sync + Send>> {
    let mut diagnostics = Vec::new();

    let mut parser = Parser::new(text);
    if let Err(e) = parser.parse_program() {
        let diagnostic = match e {
            ParseError::UnexpectedToken {
                line,
                column,
                found,
                expected,
                ..
            } => Diagnostic {
                range: Range {
                    start: Position {
                        line: (line - 1) as u32,
                        character: (column - 1) as u32,
                    },
                    end: Position {
                        line: (line - 1) as u32,
                        character: (column - 1 + found.len()) as u32,
                    },
                },
                severity: Some(DiagnosticSeverity::ERROR),
                message: format!("Unexpected token '{}', expected '{}'", found, expected),
                ..Diagnostic::default()
            },
            _ => {
                // Fallback for other errors
                Diagnostic {
                    range: Range {
                        start: Position {
                            line: 0,
                            character: 0,
                        },
                        end: Position {
                            line: 0,
                            character: 1,
                        },
                    },
                    severity: Some(DiagnosticSeverity::ERROR),
                    message: e.to_string(),
                    ..Diagnostic::default()
                }
            }
        };
        diagnostics.push(diagnostic);
    }

    let params = PublishDiagnosticsParams {
        uri,
        diagnostics,
        version: None,
    };

    let not = Notification {
        method: PublishDiagnostics::METHOD.to_string(),
        params: serde_json::to_value(params)?,
    };

    connection.sender.send(Message::Notification(not))?;

    Ok(())
}

fn get_completion_items(_params: &CompletionParams) -> Vec<CompletionItem> {
    vec![
        CompletionItem {
            label: "def".to_string(),
            kind: Some(CompletionItemKind::KEYWORD),
            ..CompletionItem::default()
        },
        // ... (can be expanded)
    ]
}

fn get_definition(params: &GotoDefinitionParams) -> Option<GotoDefinitionResponse> {
    let position = params.text_document_position_params.position;
    let document_uri = params
        .text_document_position_params
        .text_document
        .uri
        .clone();
    let document_path = document_uri.to_file_path().ok()?;
    let document_text = fs::read_to_string(document_path).ok()?;

    let mut parser = Parser::new(&document_text);
    let program = parser.parse_program().ok()?;

    let target_name = find_identifier_at_pos(
        &program,
        (position.line + 1) as usize,
        (position.character + 1) as usize,
    )?;
    let def_loc = find_definition(&program, &target_name)?;

    Some(GotoDefinitionResponse::Scalar(Location {
        uri: document_uri,
        range: Range {
            start: Position {
                line: (def_loc.line - 1) as u32,
                character: (def_loc.column - 1) as u32,
            },
            end: Position {
                line: (def_loc.line - 1) as u32,
                character: (def_loc.column - 1 + target_name.len()) as u32,
            },
        },
    }))
}

fn get_hover(params: &HoverParams) -> Option<Hover> {
    let position = params.text_document_position_params.position;
    let document_uri = params
        .text_document_position_params
        .text_document
        .uri
        .clone();
    let document_path = document_uri.to_file_path().ok()?;
    let document_text = fs::read_to_string(document_path).ok()?;

    let mut parser = Parser::new(&document_text);
    if let Ok(program) = parser.parse_program() {
        if let Some(name) = find_identifier_at_pos(
            &program,
            (position.line + 1) as usize,
            (position.character + 1) as usize,
        ) {
            if let Some(_) = find_definition(&program, &name) {
                return Some(Hover {
                    contents: HoverContents::Markup(MarkupContent {
                        kind: MarkupKind::Markdown,
                        value: format!("**Function**: `{}`", name),
                    }),
                    range: None,
                });
            }
        }
    }

    None
}

fn find_identifier_at_pos(program: &Program, line: usize, col: usize) -> Option<String> {
    for def in &program.definitions {
        if let Some(name) = find_in_def(def, line, col) {
            return Some(name);
        }
    }
    None
}

fn find_in_def(def: &Definition, line: usize, col: usize) -> Option<String> {
    match def {
        Definition::FunctionDef { body, .. } => find_in_block(body, line, col),
        _ => None,
    }
}

fn find_in_block(
    block: &bend_pvm::compiler::parser::ast::Block,
    line: usize,
    col: usize,
) -> Option<String> {
    for stmt in &block.statements {
        if let Some(name) = find_in_stmt(stmt, line, col) {
            return Some(name);
        }
    }
    None
}

fn find_in_stmt(stmt: &Statement, line: usize, col: usize) -> Option<String> {
    match stmt {
        Statement::Expr { expr, .. } => find_in_expr(expr, line, col),
        Statement::Assignment { value, .. } => find_in_expr(value, line, col),
        Statement::Return { value, .. } => find_in_expr(value, line, col),
        Statement::LocalDef { function_def, .. } => find_in_def(function_def, line, col),
        _ => None,
    }
}

fn find_in_expr(expr: &Expr, line: usize, col: usize) -> Option<String> {
    let loc = expr.location();
    match expr {
        Expr::Variable { name, location } => {
            if location.line == line && col >= location.column && col < location.column + name.len()
            {
                return Some(name.clone());
            }
            None
        }
        Expr::FunctionCall { function, args, .. } => {
            if let Some(name) = find_in_expr(function, line, col) {
                return Some(name);
            }
            for arg in args {
                if let Some(name) = find_in_expr(arg, line, col) {
                    return Some(name);
                }
            }
            None
        }
        Expr::BinaryOp { left, right, .. } => {
            if let Some(name) = find_in_expr(left, line, col) {
                return Some(name);
            }
            if let Some(name) = find_in_expr(right, line, col) {
                return Some(name);
            }
            None
        }
        _ => None,
    }
}

fn find_definition(program: &Program, name: &str) -> Option<AstLocation> {
    for def in &program.definitions {
        match def {
            Definition::FunctionDef { name: def_name, location, .. } => {
                if def_name == name {
                    return Some(location.clone());
                }
            },
            Definition::TypeDef { name: def_name, location, .. } => {
                if def_name == name {
                    return Some(location.clone());
                }
            },
            Definition::ObjectDef { name: def_name, location, .. } => {
                if def_name == name {
                    return Some(location.clone());
                }
            },
        }
    }
    None
}

fn find_references(params: &ReferenceParams) -> Option<Vec<Location>> {
    let position = params.text_document_position.position;
    let document_uri = params.text_document_position.text_document.uri.clone();
    let document_path = document_uri.to_file_path().ok()?;
    let document_text = fs::read_to_string(document_path).ok()?;
    
    let mut parser = Parser::new(&document_text);
    let program = parser.parse_program().ok()?;
    
    let target_name = find_identifier_at_pos(&program, (position.line + 1) as usize, (position.character + 1) as usize)?;
    
    let mut references = Vec::new();
    
    // Buscar referências no documento atual
    find_references_in_program(&program, &target_name, &document_uri, &mut references);
    
    Some(references)
}

fn find_references_in_program(program: &Program, target_name: &str, document_uri: &Url, references: &mut Vec<Location>) {
    // Buscar definições que usam o nome alvo
    for def in &program.definitions {
        find_references_in_definition(def, target_name, document_uri, references);
    }
}

fn find_references_in_definition(def: &Definition, target_name: &str, document_uri: &Url, references: &mut Vec<Location>) {
    match def {
        Definition::FunctionDef { name, location, body, .. } => {
            // Adicionar a própria definição se for o alvo
            if name == target_name {
                references.push(Location {
                    uri: document_uri.clone(),
                    range: Range {
                        start: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1) as u32,
                        },
                        end: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1 + name.len()) as u32,
                        },
                    },
                });
            }
            // Buscar referências no corpo da função
            find_references_in_block(body, target_name, document_uri, references);
        },
        Definition::TypeDef { name, location, .. } => {
            if name == target_name {
                references.push(Location {
                    uri: document_uri.clone(),
                    range: Range {
                        start: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1) as u32,
                        },
                        end: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1 + name.len()) as u32,
                        },
                    },
                });
            }
        },
        Definition::ObjectDef { name, location, .. } => {
            if name == target_name {
                references.push(Location {
                    uri: document_uri.clone(),
                    range: Range {
                        start: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1) as u32,
                        },
                        end: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1 + name.len()) as u32,
                        },
                    },
                });
            }
        },
    }
}

fn find_references_in_block(block: &bend_pvm::compiler::parser::ast::Block, target_name: &str, document_uri: &Url, references: &mut Vec<Location>) {
    for stmt in &block.statements {
        find_references_in_stmt(stmt, target_name, document_uri, references);
    }
}

fn find_references_in_stmt(stmt: &Statement, target_name: &str, document_uri: &Url, references: &mut Vec<Location>) {
    match stmt {
        Statement::Expr { expr, location } => {
            find_references_in_expr(expr, target_name, document_uri, references);
        },
        Statement::Assignment { name, value, location } => {
            // Verificar se o nome da atribuição é o alvo
            if name == target_name {
                references.push(Location {
                    uri: document_uri.clone(),
                    range: Range {
                        start: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1) as u32,
                        },
                        end: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1 + name.len()) as u32,
                        },
                    },
                });
            }
            find_references_in_expr(value, target_name, document_uri, references);
        },
        Statement::Return { value, location } => {
            find_references_in_expr(value, target_name, document_uri, references);
        },
        Statement::LocalDef { function_def, .. } => {
            find_references_in_definition(function_def, target_name, document_uri, references);
        },
        _ => {}
    }
}

fn find_references_in_expr(expr: &Expr, target_name: &str, document_uri: &Url, references: &mut Vec<Location>) {
    match expr {
        Expr::Variable { name, location } => {
            if name == target_name {
                references.push(Location {
                    uri: document_uri.clone(),
                    range: Range {
                        start: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1) as u32,
                        },
                        end: Position {
                            line: (location.line - 1) as u32,
                            character: (location.column - 1 + name.len()) as u32,
                        },
                    },
                });
            }
        },
        Expr::FunctionCall { function, args, location } => {
            find_references_in_expr(function, target_name, document_uri, references);
            for arg in args {
                find_references_in_expr(arg, target_name, document_uri, references);
            }
        },
        Expr::BinaryOp { left, right, .. } => {
            find_references_in_expr(left, target_name, document_uri, references);
            find_references_in_expr(right, target_name, document_uri, references);
        },
        _ => {}
    }
}
            }
            Definition::TypeDef {
                name: def_name,
                location,
                ..
            } => {
                if def_name == name {
                    return Some(location.clone());
                }
            }
            Definition::ObjectDef {
                name: def_name,
                location,
                ..
            } => {
                if def_name == name {
                    return Some(location.clone());
                }
            }
        }
    }
    None
}
