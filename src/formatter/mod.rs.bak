//! Formatter module for Bend-PVM source code
//!
//! Provides code formatting capabilities including:
//! - Indentation management
//! - Whitespace normalization
//! - Statement spacing
//! - Block formatting

use std::fs;
use std::path::Path;

/// Formatter configuration
#[derive(Debug, Clone)]
pub struct FormatterConfig {
    /// Number of spaces per indentation level
    pub indent_size: usize,

    /// Maximum line length
    pub max_line_length: usize,

    /// Whether to use tabs instead of spaces
    pub use_tabs: bool,

    /// Insert blank line after function definitions
    pub blank_line_after_fn: bool,

    /// Insert space around operators
    pub space_around_operators: bool,
}

impl Default for FormatterConfig {
    fn default() -> Self {
        Self {
            indent_size: 4,
            max_line_length: 120,
            use_tabs: false,
            blank_line_after_fn: true,
            space_around_operators: true,
        }
    }
}

/// Formatter result
#[derive(Debug, Clone)]
pub enum FormatResult {
    /// File was formatted successfully
    Formatted(String),
    /// File was already formatted correctly
    AlreadyFormatted,
    /// Format check failed - file needs formatting
    NeedsFormatting,
    /// Format failed with error
    Error(String),
}

/// Main formatter struct
pub struct Formatter {
    config: FormatterConfig,
    current_indent: usize,
}

impl Formatter {
    /// Create a new formatter with default configuration
    pub fn new() -> Self {
        Self {
            config: FormatterConfig::default(),
            current_indent: 0,
        }
    }

    /// Create a formatter with custom configuration
    pub fn with_config(config: FormatterConfig) -> Self {
        Self {
            config,
            current_indent: 0,
        }
    }

    /// Format Bend-PVM source code
    pub fn format_source(&self, source: &str) -> Result<String, String> {
        let mut result = String::new();
        let lines = source.lines().collect::<Vec<_>>();

        for line in lines {
            let formatted_line = self.format_line(line);
            result.push_str(&formatted_line);
            result.push('\n');
        }

        Ok(self.normalize_whitespace(&result))
    }

    /// Format a single line with proper indentation
    fn format_line(&mut self, line: &str) -> String {
        let trimmed = line.trim_end();
        let trimmed_start = trimmed.trim_start();

        let leading_spaces = trimmed.len() - trimmed_start.len();
        let indent_level = leading_spaces / self.config.indent_size;

        self.current_indent = indent_level;

        let body = trimmed_start.trim_start();
        if body.is_empty() {
            String::new()
        } else {
            let new_indent = self.get_indent(self.current_indent);
            format!("{}{}", new_indent, body)
        }
    }

    /// Get indentation string
    fn get_indent(&self, level: usize) -> String {
        if self.config.use_tabs {
            "\t".repeat(level)
        } else {
            " ".repeat(level * self.config.indent_size)
        }
    }

    /// Normalize whitespace in formatted code
    fn normalize_whitespace(&self, code: &str) -> String {
        let mut result = String::new();
        let mut previous_was_blank = false;

        for line in code.lines() {
            let trimmed = line.trim_end();

            if trimmed.is_empty() {
                if !previous_was_blank {
                    result.push('\n');
                    previous_was_blank = true;
                }
            } else {
                result.push_str(trimmed);
                result.push('\n');
                previous_was_blank = false;
            }
        }

        result.trim_end().to_string()
    }

    /// Check if code is already properly formatted
    pub fn is_formatted(&self, source: &str) -> bool {
        match self.format_source(source) {
            Ok(formatted) => source.trim() == formatted.trim(),
            Err(_) => false,
        }
    }

    /// Format a file and return result
    pub fn format_file(
        &self,
        file_path: &Path,
    ) -> Result<FormatResult, Box<dyn std::error::Error>> {
        let source = fs::read_to_string(file_path)?;

        if self.is_formatted(&source) {
            return Ok(FormatResult::AlreadyFormatted);
        }

        let formatted = self
            .format_source(&source)
            .map_err(|e| Box::from(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                e,
            )))?;

        Ok(FormatResult::Formatted(formatted))
    }

    /// Format a file and write result
    pub fn format_file_in_place(
        &self,
        file_path: &Path,
    ) -> Result<bool, Box<dyn std::error::Error>> {
        match self.format_file(file_path)? {
            FormatResult::Formatted(formatted) => {
                fs::write(file_path, formatted)?;
                Ok(true)
            }
            FormatResult::AlreadyFormatted => Ok(false),
            FormatResult::NeedsFormatting => Ok(true),
            FormatResult::Error(e) => Err(Box::from(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                e,
            ))),
        }
    }

    /// Format all Bend files in a directory recursively
    pub fn format_directory(
        &self,
        dir_path: &Path,
    ) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let mut formatted_files = Vec::new();

        for entry in fs::read_dir(dir_path)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_dir() {
                formatted_files.extend(self.format_directory(&path)?);
            } else if path.extension().map_or(false, |ext| ext == "bend") {
                if let FormatResult::Formatted(_) = self.format_file(&path)? {
                    formatted_files.push(path.display().to_string());
                }
            }
        }

        Ok(formatted_files)
    }
}

impl Default for Formatter {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_formatting() {
        let formatter = Formatter::new();

        let unformatted = r#"fn test(  x:i32,  y:i32  ) -> i32 {
return   x   +   y;
}"#;

        let result = formatter.format_source(unformatted);
        assert!(result.is_ok());

        if let Ok(formatted) = result {
            assert!(formatted.contains("fn test(x:i32, y:i32) -> i32"));
            assert!(formatted.contains("return x + y"));
        }
    }

    #[test]
    fn test_already_formatted() {
        let formatter = Formatter::new();

        let formatted = r#"fn test(x: i32) -> i32 {
    return x;
}"#;

        assert!(formatter.is_formatted(formatted));
    }

    #[test]
    fn test_indentation() {
        let formatter = Formatter::new();

        let unformatted = r#"fn test() -> i32 {
return 1;
}"#;

        let result = formatter.format_source(unformatted).unwrap();
        assert!(result.contains("    return 1"));
    }

    #[test]
    fn test_multiple_blank_lines() {
        let formatter = Formatter::new();

        let unformatted = r#"fn test() -> i32 {



    return 1;
}"#;

        let result = formatter.format_source(unformatted).unwrap();
        assert_eq!(result.matches("\n\n").count(), 2);
    }
}
